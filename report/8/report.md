# 課題 {-}

> 共起の強さの指標として自己相互情報量
> (負の値は0とする)を用いて、
> 果物名の(五次元！)を求めよ。

まず「イチゴ」と「切る」のペアから
自己相互情報量(PMI)を考えてみる。
まずP(イチゴ,切る)を
P(イチゴ)とP(切る)の積で除算し、
さらに底が2の対数をとった値を
I(イチゴ,切る)とする。
P(イチゴ)とP(切る)の積は
「イチゴ」と「切る」が本当に独立であった場合の値である。
他方、P(イチゴ,切る)はデータでの値である。
相互に関連があるほど独立ではなくなり、
P(イチゴ,切る)の値は上がる。
つまり、I(イチゴ,切る)は
「イチゴ」と「切る」が
どれほど独立していないか、の指標となる。

```r
df <- data.frame(
    word =c( 'イチゴ', 'ナシ', 'ミカン', 'リンゴ'),
    切る=c(371,486,137,730),
    摘む=c(84,2,18,13),
    なる=c(59,75,29,154),
    むく=c(1,52,192,97),
    もぐ=c(1,10,2,14))
#     word 切る 摘む なる むく もぐ
# 1 イチゴ  371   84   59    1    1
# 2   ナシ  486    2   75   52   10
# 3 ミカン  137   18   29  192    2
# 4 リンゴ  730   13  154   97   14
freq <- data.frame(
    word= c("切る","摘む","なる","むく","もぐ","イチゴ","ナシ","ミカン","リンゴ"),
    n = c(26600,5070,8090,3340,2160,8360,17440,12420,24500))
#     word     n
# 1   切る 26600
# 2   摘む  5070
# 3   なる  8090
# 4   むく  3340
# 5   もぐ  2160
# 6 イチゴ  8360
# 7   ナシ 17440
# 8 ミカン 12420
# 9 リンゴ 24500
```

```r
df.t <- t(df)
# the first row will be the header
colnames(df.t) = df.t[1, ]
# del first row
df.t <- df.t[-1 ,]
# このままだと数値のchar型なのでintに変更
df.t <- as.data.frame(df.t)
#      イチゴ ナシ  ミカン リンゴ
# 切る "371"  "486" "137"  "730" 
# 摘む "84"   " 2"  "18"   "13"  
# なる " 59"  " 75" " 29"  "154" 
# むく "  1"  " 52" "192"  " 97" 
# もぐ " 1"   "10"  " 2"   "14"  
```

これをベクトルの集合にしたい。
vとwをとってNを参照し、
共起回数をdfから参照し、
単語自体の頻度をfreqから参照し、
iを返す関数

```r
# N <- 20,000,000
value
N <- 20000000
i.v.w <- function(v,N,freq) function(w){
    value <- 
        log2(
        (as.numeric(as.character(df.t[w,v]))/N) /
        ((subset(freq,word==w)$"n" / N) *
         (subset(freq,word==v)$"n" / N)))
    ifelse(value>0,value,0)
    }
イチゴ <- sapply(rownames(df.t),i.v.w("イチゴ",N,freq))
ナシ   <- sapply(rownames(df.t),i.v.w("ナシ",N,freq))
ミカン <- sapply(rownames(df.t),i.v.w("ミカン",N,freq))
リンゴ <- sapply(rownames(df.t),i.v.w("リンゴ",N,freq))

lapply(list(イチゴ,ナシ,ミカン),Sim.c(リンゴ))
```

ナシ>ミカン>イチゴとなる。

```r
# lとrの内積を返す中置関数を定義
'%ip%' <- function (l,r) {
    # 入力のベクトルl,rを列に格納
    tmp <- data.frame(l=l,r=r)
    # l.rという列名の各列にl*rを格納
    tmp$l.r <- tmp$l * tmp$r 
    # l.rの和を取る
    sum(tmp$l.r)}


# ベクトル(Ws)の長さを返す関数を定義
D <- function(Ws) sqrt(sum(Ws ** 2))

# 第一引数にq(uestion), 第二引数にd(ocument vector)
Sim.c <- function(q) function(d) q %ip% d / (D(d) * D(q))
```

